<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>This Small Python Script Improved Understanding of Low-Level Programming</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">This Small Python Script Improved Understanding of Low-Level Programming</h1>
</header>
<section data-field="subtitle" class="p-summary">
A Python script that simplifies concurrency while deepening understanding of low-level concepts like CPU-bound and I/O-bound tasks
</section>
<section data-field="body" class="e-content">
<section name="bc55" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="aaf9" id="aaf9" class="graf graf--h3 graf--leading graf--title"><strong class="markup--strong markup--h3-strong">This Small Python Script Improved Understanding of Low-Level Programming</strong></h3></div><div class="section-inner sectionLayout--outsetColumn"><figure name="3bad" id="3bad" class="graf graf--figure graf--layoutOutsetCenter graf-after--h3"><img class="graf-image" data-image-id="1*NGF9X8S3cjzJeO5QGKfJsQ.jpeg" data-width="1920" data-height="1280" data-is-featured="true" src="https://cdn-images-1.medium.com/max/1200/1*NGF9X8S3cjzJeO5QGKfJsQ.jpeg"><figcaption class="imageCaption">Photo by Alexander Kovalev: <a href="https://www.pexels.com/photo/man-sitting-on-grass-using-computer-2748445/" data-href="https://www.pexels.com/photo/man-sitting-on-grass-using-computer-2748445/" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">https://www.pexels.com/photo/man-sitting-on-grass-using-computer-2748445/</a></figcaption></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="7343" id="7343" class="graf graf--p graf-after--figure">Python is widely used for its simplicity and ease of use, but for many programmers, there comes a point when the language itself no longer presents new challenges. Once developers become familiar with common libraries and techniques, the process of solving problems becomes routine. However, there is always more to learn, especially when diving into advanced topics like concurrency and low-level programming concepts.</p><p name="0ccf" id="0ccf" class="graf graf--p graf-after--p">A popular resource for those looking to take their Python skills further is the “<a href="https://talkpython.fm/" data-href="https://talkpython.fm/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Talk Python To Me</a>” podcast, which covers a broad range of topics related to Python development. One such <a href="https://training.talkpython.fm/courses/explore_async_python/async-in-python-with-threading-and-multiprocessing" data-href="https://training.talkpython.fm/courses/explore_async_python/async-in-python-with-threading-and-multiprocessing" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">course</a>, “Parallel Programming in Python with async/await and threads,” presents key concepts for handling concurrency and optimizing code execution.</p><p name="fc6e" id="fc6e" class="graf graf--p graf-after--p">In traditional computer science education, topics like computer architecture, C programming, mutexes, semaphores, and pointers are often introduced. However, many developers never truly connect these concepts with real-world programming scenarios. The understanding of CPU cores, for example, often remains abstract, disconnected from daily development tasks.</p><p name="c5b9" id="c5b9" class="graf graf--p graf-after--p">One key lesson from the course is the use of the <a href="https://pypi.org/project/unsync/" data-href="https://pypi.org/project/unsync/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">unsync</a> library, which simplifies concurrent and parallel programming by combining async, threading, and multiprocessing into a unified API. This library automatically optimizes tasks based on whether they are CPU-bound, I/O-bound, or asynchronous. By eliminating the complexities of thread initiation, joining, and closure, the unsync library makes concurrent programming in Python more accessible and efficient.</p><p name="46c2" id="46c2" class="graf graf--p graf-after--p">The following script provides a practical demonstration of these concepts:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="0b80" id="0b80" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-comment"># source: https://github.com/talkpython/async-techniques-python-course/blob/master/src/09-built-on-asyncio/the_unsync/thesync.py</span><br /><br /><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br />    t0 = datetime.datetime.now()<br /><br />    tasks = [<br />        compute_some(),<br />        compute_some(),<br />        compute_some(),<br />        download_some(),<br />        download_some(),<br />        download_some_more(),<br />        download_some_more(),<br />        wait_some(),<br />        wait_some(),<br />        wait_some(),<br />        wait_some(),<br />    ]<br /><br />    [t.result() <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> tasks]<br /><br />    dt = datetime.datetime.now() - t0<br />    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Synchronous version done in <span class="hljs-subst">{dt.total_seconds():,<span class="hljs-number">.2</span>f}</span> seconds.&quot;</span>)<br /><br /><span class="hljs-meta">@unsync(<span class="hljs-params">cpu_bound=<span class="hljs-literal">True</span></span>)</span><br /><span class="hljs-keyword">def</span> <span class="hljs-title function_">compute_some</span>():<br />    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Computing...&quot;</span>)<br />    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10_000_000</span>):<br />        math.sqrt(<span class="hljs-number">25</span> ** <span class="hljs-number">25</span> + <span class="hljs-number">.01</span>)<br /><br /><span class="hljs-meta">@unsync()</span><br /><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">download_some</span>():<br />    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Downloading...&quot;</span>)<br />    url = <span class="hljs-string">&#x27;https://talkpython.fm/episodes/show/174/coming-into-python-from-another-industry-part-2&#x27;</span><br />    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession(connector=aiohttp.TCPConnector(ssl=<span class="hljs-literal">False</span>)) <span class="hljs-keyword">as</span> session:<br />        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url) <span class="hljs-keyword">as</span> resp:<br />            resp.raise_for_status()<br /><br />            text = <span class="hljs-keyword">await</span> resp.text()<br /><br />    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Downloaded (more) <span class="hljs-subst">{<span class="hljs-built_in">len</span>(text):,}</span> characters.&quot;</span>)<br /><br /><span class="hljs-meta">@unsync()</span><br /><span class="hljs-keyword">def</span> <span class="hljs-title function_">download_some_more</span>():<br />    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Downloading more ...&quot;</span>)<br />    url = <span class="hljs-string">&#x27;https://pythonbytes.fm/episodes/show/92/will-your-python-be-compiled&#x27;</span><br />    resp = requests.get(url)<br />    resp.raise_for_status()<br /><br />    text = resp.text<br /><br />    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Downloaded <span class="hljs-subst">{<span class="hljs-built_in">len</span>(text):,}</span> characters.&quot;</span>)<br /><br /><span class="hljs-meta">@unsync()</span><br /><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">wait_some</span>():<br />    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Waiting...&quot;</span>)<br />    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>):<br />        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">.001</span>)</span></pre><p name="2016" id="2016" class="graf graf--p graf-after--pre">The script demonstrates various types of tasks and how they can be executed concurrently to improve performance and efficiency:</p><ul class="postList"><li name="75fd" id="75fd" class="graf graf--li graf-after--p">The <code class="markup--code markup--li-code">compute_some</code> function simulates heavy computations by calculating large numbers. It demonstrates how multithreaded processing can leverage multiple CPU cores to perform parallel calculations, reducing processing time and improving efficiency. In real-world applications, this approach is used for tasks like numerical simulations, data analysis, and computationally intensive operations.</li><li name="a177" id="a177" class="graf graf--li graf-after--li">The <code class="markup--code markup--li-code">download_some</code> function asynchronously fetches data from external sources (such as APIs or websites). It runs within an asyncio event loop, allowing for non-blocking I/O operations. This makes it ideal for handling multiple simultaneous I/O tasks without freezing the program, which is useful for applications that need to interact with multiple data sources at the same time, such as scraping data or handling concurrent API requests.</li><li name="1df8" id="1df8" class="graf graf--li graf-after--li">The <code class="markup--code markup--li-code">download_some_more</code> function demonstrates the use of synchronous HTTP requests. Though synchronous, it runs in a separate thread to prevent blocking the main thread. This approach is useful in simpler or legacy systems where non-blocking operations are not necessary but concurrency is still desired.</li><li name="0a58" id="0a58" class="graf graf--li graf-after--li">The <code class="markup--code markup--li-code">wait_some</code> function simulates an asynchronous task that introduces non-blocking pauses, allowing other tasks to continue running while waiting. This is particularly useful in scenarios where the program needs to wait for external events, timers, or user input without freezing other operations.</li></ul><p name="8461" id="8461" class="graf graf--p graf-after--li graf--trailing">By utilizing concurrent programming, the script shows how multiple tasks can be performed simultaneously, speeding up processing time and allowing for more efficient use of resources.</p></div></div></section><section name="3654" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="8a54" id="8a54" class="graf graf--p graf--leading">In programming, memory (RAM) and processing power (CPU) are essential components that influence performance. RAM enables fast access to active data, allowing the smooth execution of multiple tasks, while the CPU handles the execution of instructions and computations. In real-world scenarios, sufficient memory ensures that large datasets or multiple operations can be processed at once, while a powerful CPU enables faster calculations and more responsive applications.</p><p name="ab44" id="ab44" class="graf graf--p graf-after--p graf--trailing">Understanding the relationship between memory, CPU, and concurrency has a significant impact on how developers approach optimization and task execution. By leveraging multi-core CPUs and efficient memory management, developers can create more responsive, high-performance applications that handle complex, data-intensive tasks with ease.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@Kfir-G" class="p-author h-card">Kfir Gisman</a> on <a href="https://medium.com/p/077a2a066273"><time class="dt-published" datetime="2024-11-26T17:31:20.067Z">November 26, 2024</time></a>.</p><p><a href="https://medium.com/@Kfir-G/this-small-python-script-improved-understanding-of-low-level-programming-077a2a066273" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 20, 2025.</p></footer></article></body></html>