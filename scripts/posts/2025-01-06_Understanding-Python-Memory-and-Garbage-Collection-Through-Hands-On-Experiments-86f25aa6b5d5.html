<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Understanding Python Memory and Garbage Collection Through Hands-On Experiments</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Understanding Python Memory and Garbage Collection Through Hands-On Experiments</h1>
</header>
<section data-field="subtitle" class="p-summary">
Dive into Python’s memory management with practical examples to understand reference counting, garbage collection, and efficient resource…
</section>
<section data-field="body" class="e-content">
<section name="ec45" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="a48b" id="a48b" class="graf graf--h3 graf--leading graf--title">Understanding Python Memory and Garbage Collection Through Hands-On Experiments</h3><figure name="9306" id="9306" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*Dy4Yx22YWq5UItvauE0hPA.jpeg" data-width="1280" data-height="1599" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*Dy4Yx22YWq5UItvauE0hPA.jpeg"><figcaption class="imageCaption">Photo by badr mourafiq: <a href="https://www.pexels.com/photo/creative-iphone-new-york-sony-9136482/" data-href="https://www.pexels.com/photo/creative-iphone-new-york-sony-9136482/" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">https://www.pexels.com/photo/creative-iphone-new-york-sony-9136482/</a></figcaption></figure><p name="6068" id="6068" class="graf graf--p graf-after--figure">Python is a high-level language that takes care of much of the memory management for you. However, understanding how it works under the hood can give you better insights into performance optimization and how to manage your resources efficiently. In this blog post, we’ll explore <strong class="markup--strong markup--p-strong">Python’s memory management</strong> and <strong class="markup--strong markup--p-strong">garbage collection (GC)</strong> with hands-on examples. We will focus on three core concepts:</p><ol class="postList"><li name="0b73" id="0b73" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Memory Allocation and Reference Counting</strong></li><li name="8ce2" id="8ce2" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Cyclic References</strong></li><li name="5a2f" id="5a2f" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Using </strong><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">gc</strong></code><strong class="markup--strong markup--li-strong"> to Manage Garbage Collection</strong></li></ol><p name="810f" id="810f" class="graf graf--p graf-after--li graf--trailing">Let’s dive in with an experiment-driven approach using a small Python script that demonstrates these concepts in action.</p></div></div></section><section name="551d" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="f1f4" id="f1f4" class="graf graf--h3 graf--leading">1. Memory Allocation and Reference Counting</h3><p name="f6d6" id="f6d6" class="graf graf--p graf-after--h3">Memory management in Python is primarily handled through <strong class="markup--strong markup--p-strong">reference counting</strong>. Every object in Python has a reference count that tracks how many references point to it. When the reference count drops to zero, the object is automatically deleted, and its memory is freed.</p><h4 name="7e3d" id="7e3d" class="graf graf--h4 graf-after--p">Example: Memory Allocation of Simple Objects</h4><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="4b56" id="4b56" class="graf graf--pre graf-after--h4 graf--preV2"><span class="pre--content"><span class="hljs-keyword">import</span> sys<br /><br /><span class="hljs-comment"># Create two variables pointing to the same integer object</span><br />x = <span class="hljs-number">10</span><br />y = <span class="hljs-number">10</span>  <span class="hljs-comment"># Both x and y point to the same memory location</span><br /><br /><span class="hljs-comment"># Memory address and reference count</span><br /><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Memory address of x (ID): <span class="hljs-subst">{<span class="hljs-built_in">id</span>(x)}</span>&quot;</span>)<br /><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Memory address of y (ID): <span class="hljs-subst">{<span class="hljs-built_in">id</span>(y)}</span>&quot;</span>)<br /><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Reference count for x: <span class="hljs-subst">{sys.getrefcount(x)}</span>&quot;</span>)</span></pre><p name="39ac" id="39ac" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Key Points:</strong></p><ul class="postList"><li name="032d" id="032d" class="graf graf--li graf-after--p">Both <code class="markup--code markup--li-code">x</code> and <code class="markup--code markup--li-code">y</code> point to the same integer object (<code class="markup--code markup--li-code">10</code>), as integers are cached in Python.</li><li name="beee" id="beee" class="graf graf--li graf-after--li">The <code class="markup--code markup--li-code">id()</code> function shows that both variables share the same memory address.</li><li name="f5d2" id="f5d2" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">sys.getrefcount()</code> reveals that the reference count is greater than 1 because both <code class="markup--code markup--li-code">x</code> and <code class="markup--code markup--li-code">y</code> reference the same object.</li></ul><p name="afe0" id="afe0" class="graf graf--p graf-after--li">After deleting one of the references (<code class="markup--code markup--p-code">del x</code>), the object is still alive because <code class="markup--code markup--p-code">y</code> still holds a reference to the object.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="d470" id="d470" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">del</span> x<br /><br /><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Reference count after deleting x: <span class="hljs-subst">{sys.getrefcount(y)}</span>&quot;</span>)</span></pre><h4 name="092e" id="092e" class="graf graf--h4 graf-after--pre">Output:</h4><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="bash" name="ebe0" id="ebe0" class="graf graf--pre graf-after--h4 graf--preV2"><span class="pre--content">Memory address of x (ID): 140705611380560<br />Memory address of y (ID): 140705611380560<br />Reference count <span class="hljs-keyword">for</span> x: 2<br />Reference count after deleting x: 1</span></pre><p name="1a6f" id="1a6f" class="graf graf--p graf-after--pre graf--trailing">As shown, the reference count of the object decreases after <code class="markup--code markup--p-code">x</code> is deleted, but the object is still not destroyed because <code class="markup--code markup--p-code">y</code> still holds a reference to it.</p></div></div></section><section name="45b6" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="d24b" id="d24b" class="graf graf--h3 graf--leading">2. Cyclic References and Garbage Collection</h3><p name="e077" id="e077" class="graf graf--p graf-after--h3">Sometimes, objects reference each other in a cycle (e.g., <code class="markup--code markup--p-code">A -&gt; B -&gt; A</code>), making it impossible for the reference count to reach zero. Python’s garbage collector handles these cases by detecting and cleaning up cyclic references.</p><h4 name="c796" id="c796" class="graf graf--h4 graf-after--p">Example: Creating a Cycle</h4><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="ruby" name="2cbd" id="2cbd" class="graf graf--pre graf-after--h4 graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>:<br />    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"><span class="hljs-variable language_">self</span>, value</span>):<br />        <span class="hljs-variable language_">self</span>.value = value<br />        <span class="hljs-variable language_">self</span>.<span class="hljs-keyword">next</span> = <span class="hljs-title class_">None</span><br /><br /><span class="hljs-comment"># Create a cycle</span><br />node1 = <span class="hljs-title class_">Node</span>(<span class="hljs-number">1</span>)<br />node2 = <span class="hljs-title class_">Node</span>(<span class="hljs-number">2</span>)<br />node1.<span class="hljs-keyword">next</span> = node2<br />node2.<span class="hljs-keyword">next</span> = node1  <span class="hljs-comment"># This creates a cyclic reference</span></span></pre><p name="c03d" id="c03d" class="graf graf--p graf-after--pre">Here, <code class="markup--code markup--p-code">node1</code> and <code class="markup--code markup--p-code">node2</code> reference each other, forming a cycle. Even after deleting both references, the objects are not collected because they still reference each other.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="python" name="7e0d" id="7e0d" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">del</span> node1<br /><span class="hljs-keyword">del</span> node2</span></pre><h3 name="e877" id="e877" class="graf graf--h3 graf-after--pre">Triggering Garbage Collection</h3><p name="d47f" id="d47f" class="graf graf--p graf-after--h3">To break the cycle and reclaim memory, Python’s garbage collector (<code class="markup--code markup--p-code">gc</code>) can be manually triggered using <code class="markup--code markup--p-code">gc.collect()</code>.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="ed07" id="ed07" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">import</span> gc<br /><br /><span class="hljs-comment"># Manually trigger garbage collection to clean up the cycle</span><br />gc.collect()</span></pre><p name="9e74" id="9e74" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Key Point:</strong></p><ul class="postList"><li name="3f0e" id="3f0e" class="graf graf--li graf-after--p">Python’s GC is able to detect and clean up cyclic references, ensuring that memory is freed even when reference counting can’t handle it.</li></ul><h3 name="c512" id="c512" class="graf graf--h3 graf-after--li">3. Using <code class="markup--code markup--h3-code">gc</code> for Custom Garbage Collection</h3><p name="97d7" id="97d7" class="graf graf--p graf-after--h3">Python provides the <code class="markup--code markup--p-code">gc</code> module to interact with the garbage collector and control the cleanup process. We can check if garbage collection is enabled and even force a collection to clean up unreachable objects.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="1f62" id="1f62" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">import</span> gc<br /><br /><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Is Garbage Collection enabled? <span class="hljs-subst">{gc.isenabled()}</span>&quot;</span>)<br />gc.collect()  <span class="hljs-comment"># Force garbage collection</span><br /><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Garbage after collect: <span class="hljs-subst">{gc.garbage}</span>&quot;</span>)</span></pre><p name="eca6" id="eca6" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Key Points:</strong></p><ul class="postList"><li name="bc60" id="bc60" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">gc.isenabled()</code> checks if garbage collection is enabled in the current Python session.</li><li name="a842" id="a842" class="graf graf--li graf-after--li graf--trailing"><code class="markup--code markup--li-code">gc.collect()</code> forces the garbage collection process, which can help clean up cyclic references or unreachable objects.</li></ul></div></div></section><section name="6746" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="05ca" id="05ca" class="graf graf--h3 graf--leading">4. Using <code class="markup--code markup--h3-code">__del__</code> for Custom Cleanup</h3><p name="3580" id="3580" class="graf graf--p graf-after--h3">Python allows you to define custom cleanup code using the <code class="markup--code markup--p-code">__del__</code> method. This method is called when an object is about to be destroyed.</p><h4 name="f953" id="f953" class="graf graf--h4 graf-after--p">Example: Using <code class="markup--code markup--h4-code">__del__</code></h4><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="7356" id="7356" class="graf graf--pre graf-after--h4 graf--preV2"><span class="pre--content"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObject</span>:<br />    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>):<br />        self.name = name<br />        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;MyObject <span class="hljs-subst">{self.name}</span> is created!&quot;</span>)<br /><br />    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__del__</span>(<span class="hljs-params">self</span>):<br />        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;MyObject <span class="hljs-subst">{self.name}</span> is being destroyed!&quot;</span>)<br /><br />obj1 = MyObject(<span class="hljs-string">&quot;Object 1&quot;</span>)<br />obj2 = obj1  <span class="hljs-comment"># obj2 is another reference to the same object</span><br /><br /><span class="hljs-keyword">del</span> obj1     <span class="hljs-comment"># This will not delete the object, as obj2 still holds a reference</span><br /><span class="hljs-keyword">del</span> obj2     <span class="hljs-comment"># The object is now destroyed because both references are gone</span></span></pre><p name="3fb8" id="3fb8" class="graf graf--p graf-after--pre">In this example:</p><ul class="postList"><li name="c1ea" id="c1ea" class="graf graf--li graf-after--p">When <code class="markup--code markup--li-code">obj1</code> is deleted, the object is not destroyed because <code class="markup--code markup--li-code">obj2</code> still holds a reference to it.</li><li name="c2da" id="c2da" class="graf graf--li graf-after--li graf--trailing">When <code class="markup--code markup--li-code">obj2</code> is also deleted, the object’s <code class="markup--code markup--li-code">__del__</code> method is called, and the object is destroyed.</li></ul></div></div></section><section name="bc71" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="5675" id="5675" class="graf graf--h3 graf--leading">Conclusion</h3><p name="d2cc" id="d2cc" class="graf graf--p graf-after--h3">Python’s memory management and garbage collection mechanisms are designed to handle most tasks automatically. By understanding <strong class="markup--strong markup--p-strong">reference counting</strong> and <strong class="markup--strong markup--p-strong">cyclic references</strong>, as well as how to manually trigger the garbage collector, you can ensure that your programs are more efficient and resource-friendly.</p><p name="dc3a" id="dc3a" class="graf graf--p graf-after--p">By experimenting with these examples, you gain hands-on experience in how Python manages memory, how cyclic references are handled, and how to clean up resources using the <code class="markup--code markup--p-code">gc</code> module.</p><p name="b5db" id="b5db" class="graf graf--p graf-after--p">Keep in mind:</p><ul class="postList"><li name="a6f5" id="a6f5" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Reference Counting</strong>: Keeps track of object references and deletes objects when they are no longer referenced.</li><li name="ef16" id="ef16" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Garbage Collection</strong>: Handles cyclic references that reference counting can’t clean up.</li><li name="e08c" id="e08c" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">__del__</strong></code><strong class="markup--strong markup--li-strong"> Method</strong>: Allows for custom cleanup when objects are destroyed.</li></ul><p name="94d5" id="94d5" class="graf graf--p graf-after--li graf--trailing">This knowledge helps you write more efficient and optimized Python code, particularly for resource-intensive applications.</p></div></div></section><section name="9896" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="d76c" id="d76c" class="graf graf--h3 graf--leading">References</h3><ul class="postList"><li name="1583" id="1583" class="graf graf--li graf-after--h3"><a href="https://docs.python.org/3/c-api/memory.html" data-href="https://docs.python.org/3/c-api/memory.html" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Memory Management</a></li><li name="6907" id="6907" class="graf graf--li graf-after--li"><a href="https://www.geeksforgeeks.org/memory-management-in-python/" data-href="https://www.geeksforgeeks.org/memory-management-in-python/" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Memory Management in Python</a></li><li name="19f6" id="19f6" class="graf graf--li graf-after--li"><a href="https://docs.python.org/3/library/gc.html" data-href="https://docs.python.org/3/library/gc.html" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">gc — Garbage Collector interface</a></li><li name="531f" id="531f" class="graf graf--li graf-after--li"><a href="https://www.geeksforgeeks.org/garbage-collection-python/" data-href="https://www.geeksforgeeks.org/garbage-collection-python/" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Garbage Collection in Python</a></li><li name="a914" id="a914" class="graf graf--li graf-after--li graf--trailing"><a href="https://github.com/python/cpython/blob/main/InternalDocs/garbage_collector.md" data-href="https://github.com/python/cpython/blob/main/InternalDocs/garbage_collector.md" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">garbage collector</a></li></ul></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@Kfir-G" class="p-author h-card">Kfir Gisman</a> on <a href="https://medium.com/p/86f25aa6b5d5"><time class="dt-published" datetime="2025-01-06T01:44:00.686Z">January 6, 2025</time></a>.</p><p><a href="https://medium.com/@Kfir-G/understanding-python-memory-and-garbage-collection-through-hands-on-experiments-86f25aa6b5d5" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 20, 2025.</p></footer></article></body></html>