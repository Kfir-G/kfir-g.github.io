<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Understanding Atomicity in PostgreSQL: A Deep Dive into the “A” in ACID</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Understanding Atomicity in PostgreSQL: A Deep Dive into the “A” in ACID</h1>
</header>
<section data-field="subtitle" class="p-summary">
Why atomicity matters: how PostgreSQL ensures all-or-nothing transactions and what can go wrong if you skip BEGIN
</section>
<section data-field="body" class="e-content">
<section name="ce55" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="2f39" id="2f39" class="graf graf--h3 graf--leading graf--title">Understanding Atomicity in PostgreSQL: A Deep Dive into the “A” in ACID</h3><figure name="a90f" id="a90f" class="graf graf--figure graf-after--h3 graf--trailing"><img class="graf-image" data-image-id="1*by0EZDhNnatcIASaS2YoWQ.jpeg" data-width="3003" data-height="4007" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*by0EZDhNnatcIASaS2YoWQ.jpeg"><figcaption class="imageCaption">Photo by Thiago Matos : <a href="https://www.pexels.com/photo/orange-led-cfl-bulb-2338672/" data-href="https://www.pexels.com/photo/orange-led-cfl-bulb-2338672/" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">https://www.pexels.com/photo/orange-led-cfl-bulb-2338672/</a></figcaption></figure></div></div></section><section name="76a1" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="020b" id="020b" class="graf graf--p graf--leading">In production systems that manage critical data- whether financial transactions, user state, or infrastructure configuration- the integrity of state transitions is non-negotiable. That’s where the ACID properties of relational databases come into play.</p><p name="ddca" id="ddca" class="graf graf--p graf-after--p">This article takes a focused look at <strong class="markup--strong markup--p-strong">Atomicity</strong>, the first principle of ACID. We’ll analyze how PostgreSQL enforces it, how failures are handled, and what engineers must understand to avoid subtle consistency bugs in real-world systems.</p><h3 name="1d65" id="1d65" class="graf graf--h3 graf-after--p">What Atomicity Really Means</h3><p name="6336" id="6336" class="graf graf--p graf-after--h3">Atomicity guarantees that a <strong class="markup--strong markup--p-strong">transaction is all-or-nothing</strong>: every operation in the transaction either completes successfully, or none of them do. There is no concept of “partial success.”</p><p name="56ef" id="56ef" class="graf graf--p graf-after--p">Atomicity is enforced at the transaction level, not the statement level. PostgreSQL ensures that even if a failure occurs midway through a transaction, all previous operations in that transaction are automatically rolled back.</p><p name="e858" id="e858" class="graf graf--p graf-after--p">For reference, see the official <a href="https://www.postgresql.org/docs/current/tutorial-transactions.html" data-href="https://www.postgresql.org/docs/current/tutorial-transactions.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">PostgreSQL Transaction Tutorial</a>.</p><h3 name="cff3" id="cff3" class="graf graf--h3 graf-after--p">A Simple Transfer Operation</h3><p name="9e82" id="9e82" class="graf graf--p graf-after--h3">Consider a simplified banking example. We’ll create an <code class="markup--code markup--p-code">accounts</code> table and simulate transferring funds between two accounts:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="8c57" id="8c57" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> accounts (<br />    id SERIAL <span class="hljs-keyword">PRIMARY</span> KEY,<br />    name TEXT <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br />    balance <span class="hljs-type">INTEGER</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">CHECK</span> (balance <span class="hljs-operator">&gt;=</span> <span class="hljs-number">0</span>)<br />);<br /><br /><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> accounts (name, balance)<br /><span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;Alice&#x27;</span>, <span class="hljs-number">1000</span>), (<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">1000</span>);</span></pre><p name="b1a8" id="b1a8" class="graf graf--p graf-after--pre">Now, we implement a basic transfer operation using an explicit transaction:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="6b5d" id="6b5d" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">BEGIN</span>;<br /><br /><span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">-</span> <span class="hljs-number">200</span> <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Alice&#x27;</span>;<br /><span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">+</span> <span class="hljs-number">200</span> <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Bob&#x27;</span>;<br /><br /><span class="hljs-keyword">COMMIT</span>;</span></pre><p name="97e5" id="97e5" class="graf graf--p graf-after--pre">If both statements succeed, the transaction is committed and both updates become permanent.</p><h3 name="313e" id="313e" class="graf graf--h3 graf-after--p">Simulating a Failure</h3><p name="77c9" id="77c9" class="graf graf--p graf-after--h3">Now let’s simulate an error that occurs in the second statement:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="a051" id="a051" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">BEGIN</span>;<br /><br /><span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">-</span> <span class="hljs-number">200</span> <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Alice&#x27;</span>;<br /><span class="hljs-comment">-- Intentional typo: column name is misspelled</span><br /><span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> balnce <span class="hljs-operator">=</span> balance <span class="hljs-operator">+</span> <span class="hljs-number">200</span> <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Bob&#x27;</span>;<br /><br /><span class="hljs-keyword">COMMIT</span>;</span></pre><p name="7307" id="7307" class="graf graf--p graf-after--pre">PostgreSQL will raise an error:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="46cc" id="46cc" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">ERROR: <span class="hljs-keyword">column</span> &quot;balnce&quot; does <span class="hljs-keyword">not</span> exist</span></pre><p name="cc2a" id="cc2a" class="graf graf--p graf-after--pre">At this point, the transaction is marked as failed. No further operations are allowed until a rollback is issued:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="c268" id="c268" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">ROLLBACK</span>;</span></pre><p name="c2a2" id="c2a2" class="graf graf--p graf-after--pre">Although the first <code class="markup--code markup--p-code">UPDATE</code> ran without error, its effect is discarded because the transaction was never successfully committed. This is atomicity in practice.</p><h3 name="4372" id="4372" class="graf graf--h3 graf-after--p">What If You Don’t Use Transactions?</h3><p name="a7e8" id="a7e8" class="graf graf--p graf-after--h3">When operations are issued individually without an explicit <code class="markup--code markup--p-code">BEGIN</code> block, PostgreSQL executes each as its own atomic unit:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="f69d" id="f69d" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">-</span> <span class="hljs-number">200</span> <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Alice&#x27;</span>;<br /><span class="hljs-comment">-- This succeeds</span><br /><br /><span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> balnce <span class="hljs-operator">=</span> balance <span class="hljs-operator">+</span> <span class="hljs-number">200</span> <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Bob&#x27;</span>;<br /><span class="hljs-comment">-- This fails</span></span></pre><p name="4fe7" id="4fe7" class="graf graf--p graf-after--pre">Here, Alice’s balance is reduced, but Bob never receives the funds. This violates our consistency requirements and results in data loss.</p><p name="fe2b" id="fe2b" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Lesson:</strong> without explicit transactions, the database cannot enforce atomicity across multiple operations.</p><h3 name="045d" id="045d" class="graf graf--h3 graf-after--p">Statement-Level Atomicity</h3><p name="2d02" id="2d02" class="graf graf--p graf-after--h3">PostgreSQL does provide implicit transaction handling for single statements. If a single <code class="markup--code markup--p-code">INSERT</code>, <code class="markup--code markup--p-code">UPDATE</code>, or <code class="markup--code markup--p-code">DELETE</code> statement fails, it is discarded entirely and does not affect the database. However, for multiple operations that must succeed together, atomicity is not guaranteed unless you explicitly wrap them in a transaction.</p><p name="dcc3" id="dcc3" class="graf graf--p graf-after--p">Relevant documentation: <a href="https://www.postgresql.org/docs/current/sql-begin.html" data-href="https://www.postgresql.org/docs/current/sql-begin.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">PostgreSQL BEGIN</a></p><h3 name="3680" id="3680" class="graf graf--h3 graf-after--p">Constraint Failures and Runtime Errors</h3><p name="69e6" id="69e6" class="graf graf--p graf-after--h3">PostgreSQL also enforces atomicity in the presence of constraint violations or other runtime errors. For example, suppose we enforce that balances cannot be negative:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="a6f4" id="a6f4" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> accounts <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> non_negative_balance <span class="hljs-keyword">CHECK</span> (balance <span class="hljs-operator">&gt;=</span> <span class="hljs-number">0</span>);</span></pre><p name="0d0c" id="0d0c" class="graf graf--p graf-after--pre">Then attempt:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="a675" id="a675" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">BEGIN</span>;<br /><br /><span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">-</span> <span class="hljs-number">1100</span> <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Alice&#x27;</span>;<br /><span class="hljs-keyword">UPDATE</span> accounts <span class="hljs-keyword">SET</span> balance <span class="hljs-operator">=</span> balance <span class="hljs-operator">+</span> <span class="hljs-number">1100</span> <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Bob&#x27;</span>;<br /><br /><span class="hljs-keyword">COMMIT</span>;</span></pre><p name="ee42" id="ee42" class="graf graf--p graf-after--pre">Alice only has 1000, so her balance would go negative. The first statement violates the constraint, and the entire transaction is aborted. No changes are applied.</p><h3 name="3198" id="3198" class="graf graf--h3 graf-after--p">Handling Transactions in Application Code</h3><p name="5317" id="5317" class="graf graf--p graf-after--h3">Here’s how atomicity works in a real-world PostgreSQL client using Python with <a href="https://www.psycopg.org/psycopg3/docs/basic/transactions.html" data-href="https://www.psycopg.org/psycopg3/docs/basic/transactions.html" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">psycopg3</a>:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="8386" id="8386" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">import</span> psycopg<br /><br />conn = psycopg.connect(<span class="hljs-string">&quot;postgresql://user:pass@localhost/db&quot;</span>)<br /><br /><span class="hljs-keyword">try</span>:<br />    <span class="hljs-keyword">with</span> conn.transaction():<br />        <span class="hljs-keyword">with</span> conn.cursor() <span class="hljs-keyword">as</span> cur:<br />            cur.execute(<span class="hljs-string">&quot;UPDATE accounts SET balance = balance - 200 WHERE name = &#x27;Alice&#x27;&quot;</span>)<br />            cur.execute(<span class="hljs-string">&quot;UPDATE accounts SET balnce = balance + 200 WHERE name = &#x27;Bob&#x27;&quot;</span>)  <span class="hljs-comment"># Bug</span><br /><br /><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br />    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Transaction failed: <span class="hljs-subst">{e}</span>&quot;</span>)</span></pre><p name="830b" id="830b" class="graf graf--p graf-after--pre">In this case, <code class="markup--code markup--p-code">conn.transaction()</code> ensures that the entire block is treated as atomic. When the second query fails, psycopg3 automatically rolls back the transaction. No data is persisted.</p><h3 name="2792" id="2792" class="graf graf--h3 graf-after--p">Summary of Cases</h3><ul class="postList"><li name="1b1f" id="1b1f" class="graf graf--li graf-after--h3"><strong class="markup--strong markup--li-strong">Single </strong><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">UPDATE</strong></code>: Executed without an explicit transaction block, PostgreSQL treats it as an implicit transaction. It either succeeds or fails as a single atomic operation.</li><li name="a24c" id="a24c" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Multiple </strong><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">UPDATE</strong></code><strong class="markup--strong markup--li-strong">s without </strong><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">BEGIN</strong></code>: When multiple operations are issued individually without wrapping them in a transaction, atomicity is not guaranteed. If one statement succeeds and another fails, partial state changes can persist.</li><li name="3c1c" id="3c1c" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">BEGIN</strong></code><strong class="markup--strong markup--li-strong"> / </strong><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">COMMIT</strong></code><strong class="markup--strong markup--li-strong"> with syntax or runtime error</strong>: When using an explicit transaction, any error- be it a syntax issue or constraint violation- causes the entire transaction to be rolled back. This ensures atomicity across all enclosed operations.</li><li name="4aaf" id="4aaf" class="graf graf--li graf-after--li graf--trailing"><strong class="markup--strong markup--li-strong">Using psycopg3 with </strong><code class="markup--code markup--li-code"><strong class="markup--strong markup--li-strong">with conn.transaction()</strong></code>: In application code, using this context manager ensures atomicity. If any exception is raised during the block, psycopg3 automatically rolls back the transaction.</li></ul></div></div></section><section name="3ef4" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="c6f1" id="c6f1" class="graf graf--h3 graf--leading">Final Thoughts</h3><p name="e61b" id="e61b" class="graf graf--p graf-after--h3">PostgreSQL provides strong atomicity guarantees, but they’re only effective when transactions are used intentionally and correctly. Multi-statement operations should <strong class="markup--strong markup--p-strong">always</strong> be wrapped in an explicit transaction, and developers must anticipate rollback paths as part of the application’s normal flow.</p><p name="8c82" id="8c82" class="graf graf--p graf-after--p">Failing to do so can result in partial writes, corrupted state, and long-tail data integrity bugs that are difficult to trace.</p><p name="8f78" id="8f78" class="graf graf--p graf-after--p">For more details, refer to the official documentation:</p><ul class="postList"><li name="4a4d" id="4a4d" class="graf graf--li graf-after--p"><a href="https://www.postgresql.org/docs/current/tutorial-transactions.html" data-href="https://www.postgresql.org/docs/current/tutorial-transactions.html" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">PostgreSQL Transactions</a></li><li name="cea8" id="cea8" class="graf graf--li graf-after--li"><a href="https://www.postgresql.org/docs/current/sql-begin.html" data-href="https://www.postgresql.org/docs/current/sql-begin.html" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">BEGIN</a></li><li name="05bf" id="05bf" class="graf graf--li graf-after--li"><a href="https://www.postgresql.org/docs/current/sql-commit.html" data-href="https://www.postgresql.org/docs/current/sql-commit.html" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">COMMIT</a></li><li name="ca93" id="ca93" class="graf graf--li graf-after--li"><a href="https://www.postgresql.org/docs/current/sql-rollback.html" data-href="https://www.postgresql.org/docs/current/sql-rollback.html" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">ROLLBACK</a></li><li name="74c9" id="74c9" class="graf graf--li graf-after--li graf--trailing"><a href="https://www.psycopg.org/psycopg3/docs/basic/transactions.html" data-href="https://www.psycopg.org/psycopg3/docs/basic/transactions.html" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">psycopg3 Transactions</a></li></ul></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@Kfir-G" class="p-author h-card">Kfir Gisman</a> on <a href="https://medium.com/p/5bde6fd042e3"><time class="dt-published" datetime="2025-05-12T14:25:59.258Z">May 12, 2025</time></a>.</p><p><a href="https://medium.com/@Kfir-G/understanding-atomicity-in-postgresql-a-deep-dive-into-the-a-in-acid-5bde6fd042e3" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 20, 2025.</p></footer></article></body></html>