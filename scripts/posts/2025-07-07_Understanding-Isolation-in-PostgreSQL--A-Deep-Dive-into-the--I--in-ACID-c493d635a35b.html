<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Understanding Isolation in PostgreSQL: A Deep Dive into the “I” in ACID</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Understanding Isolation in PostgreSQL: A Deep Dive into the “I” in ACID</h1>
</header>
<section data-field="subtitle" class="p-summary">
How does PostgreSQL keep your transactions from stepping on each other? Dive deep into Isolation- the ‘I’ in ACID -with real examples
</section>
<section data-field="body" class="e-content">
<section name="94b3" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="3caa" id="3caa" class="graf graf--h3 graf--leading graf--title">Understanding Isolation in PostgreSQL: A Deep Dive into the “I” in ACID</h3><figure name="aea7" id="aea7" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*w8bYYfVQxfSZuy1dzA07Ng.jpeg" data-width="1280" data-height="1707" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*w8bYYfVQxfSZuy1dzA07Ng.jpeg"><figcaption class="imageCaption">Photo by Matheus Viana: <a href="https://www.pexels.com/photo/open-locker-in-wooden-locker-room-31220117/" data-href="https://www.pexels.com/photo/open-locker-in-wooden-locker-room-31220117/" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">https://www.pexels.com/photo/open-locker-in-wooden-locker-room-31220117/</a></figcaption></figure><p name="06d2" id="06d2" class="graf graf--p graf-after--figure">When we talk about PostgreSQL being <em class="markup--em markup--p-em">ACID-compliant</em>, Isolation is the “I” that quietly does a lot of heavy lifting. In my previous articles, we explored Atomicity and Consistency -how PostgreSQL makes sure that transactions either happen fully or not at all, and that the database remains valid. Now it’s time to look at how Isolation keeps transactions from interfering with each other when multiple operations run at the same time.</p><p name="670b" id="670b" class="graf graf--p graf-after--p graf--trailing">Isolation sounds simple: each transaction should run as if it’s the only one. But the details can get tricky, especially when different isolation levels come into play. Let’s see what this means, how it works in PostgreSQL, and what to watch out for.</p></div></div></section><section name="5d70" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="0b70" id="0b70" class="graf graf--h3 graf--leading">What Isolation Means</h3><p name="38c9" id="38c9" class="graf graf--p graf-after--h3">In short, Isolation makes sure that the intermediate state of a transaction is invisible to other transactions. If one transaction is in the middle of changing a row, another transaction shouldn’t see a half-finished version of that row.</p><p name="006b" id="006b" class="graf graf--p graf-after--p">Without Isolation, you can run into problems like:</p><ul class="postList"><li name="f733" id="f733" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Dirty reads</strong>: reading uncommitted changes that might get rolled back.</li><li name="199b" id="199b" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Non-repeatable reads</strong>: getting different results when you read the same row twice in a transaction.</li><li name="112d" id="112d" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Phantom reads</strong>: rows appear or disappear when you run the same query again.</li></ul><p name="398c" id="398c" class="graf graf--p graf-after--li graf--trailing">PostgreSQL handles this with different isolation levels, each balancing correctness and performance.</p></div></div></section><section name="781e" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="79d0" id="79d0" class="graf graf--h3 graf--leading">PostgreSQL’s Isolation Levels</h3><p name="2309" id="2309" class="graf graf--p graf-after--h3">PostgreSQL supports the standard SQL isolation levels:</p><ol class="postList"><li name="134e" id="134e" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Read Uncommitted</strong><br> PostgreSQL actually treats this the same as Read Committed, so dirty reads are never allowed.</li><li name="c383" id="c383" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Read Committed</strong> (default)<br> Each query sees a snapshot of the database taken at the start of that query. Changes committed by other transactions become visible to the next query in the same transaction.</li><li name="9322" id="9322" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Repeatable Read</strong><br> All queries in the transaction see the same snapshot taken when the transaction starts. You avoid non-repeatable reads, but phantom reads can still happen.</li><li name="1fac" id="1fac" class="graf graf--li graf-after--li graf--trailing"><strong class="markup--strong markup--li-strong">Serializable</strong><br> The strictest level. Transactions run as if they were executed one after another. PostgreSQL uses Serializable Snapshot Isolation (SSI) to make this work and may abort transactions that can’t be serialized.</li></ol></div></div></section><section name="2b8a" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="4113" id="4113" class="graf graf--h3 graf--leading">Let’s See Isolation in Action</h3><p name="3c6b" id="3c6b" class="graf graf--p graf-after--h3">Here’s a simple table to experiment with:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="976c" id="976c" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> inventory (<br />  id SERIAL <span class="hljs-keyword">PRIMARY</span> KEY,<br />  stock <span class="hljs-type">INT</span><br />);<br /><br /><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> inventory (stock) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">100</span>);</span></pre><p name="9457" id="9457" class="graf graf--p graf-after--pre graf--trailing">Open two <code class="markup--code markup--p-code">psql</code> sessions: Session A and Session B.</p></div></div></section><section name="0fd9" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="2a85" id="2a85" class="graf graf--h3 graf--leading">Read Committed: Non-Repeatable Reads</h3><p name="c1a4" id="c1a4" class="graf graf--p graf-after--h3">In Session A:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="e5b7" id="e5b7" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">BEGIN</span>;<br /><span class="hljs-keyword">SET</span> TRANSACTION ISOLATION LEVEL READ COMMITTED;<br /><br /><span class="hljs-keyword">SELECT</span> stock <span class="hljs-keyword">FROM</span> inventory <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br /><span class="hljs-comment">-- stock = 100</span></span></pre><p name="174d" id="174d" class="graf graf--p graf-after--pre">In Session B:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="136a" id="136a" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">UPDATE</span> inventory <span class="hljs-keyword">SET</span> stock <span class="hljs-operator">=</span> <span class="hljs-number">50</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br /><span class="hljs-keyword">COMMIT</span>;</span></pre><p name="070a" id="070a" class="graf graf--p graf-after--pre">Back in Session A:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="0ac0" id="0ac0" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">SELECT</span> stock <span class="hljs-keyword">FROM</span> inventory <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br /><span class="hljs-comment">-- stock = 50</span></span></pre><p name="4954" id="4954" class="graf graf--p graf-after--pre graf--trailing">The same row gave a different value within the same transaction. This is a non-repeatable read, and it’s allowed in Read Committed.</p></div></div></section><section name="5080" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="bda7" id="bda7" class="graf graf--h3 graf--leading">Repeatable Read: Same Snapshot</h3><p name="b440" id="b440" class="graf graf--p graf-after--h3">Now try Repeatable Read.</p><p name="71fa" id="71fa" class="graf graf--p graf-after--p">Session A:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="d5ff" id="d5ff" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">BEGIN</span>;<br /><span class="hljs-keyword">SET</span> TRANSACTION ISOLATION LEVEL REPEATABLE READ;<br /><br /><span class="hljs-keyword">SELECT</span> stock <span class="hljs-keyword">FROM</span> inventory <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br /><span class="hljs-comment">-- stock = 100</span></span></pre><p name="2b9e" id="2b9e" class="graf graf--p graf-after--pre">Session B:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="e6b4" id="e6b4" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">UPDATE</span> inventory <span class="hljs-keyword">SET</span> stock <span class="hljs-operator">=</span> <span class="hljs-number">30</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br /><span class="hljs-keyword">COMMIT</span>;</span></pre><p name="e287" id="e287" class="graf graf--p graf-after--pre">Back in Session A:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="ed92" id="ed92" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">SELECT</span> stock <span class="hljs-keyword">FROM</span> inventory <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br /><span class="hljs-comment">-- stock = 100</span></span></pre><p name="8a70" id="8a70" class="graf graf--p graf-after--pre graf--trailing">This time, the value stays the same because Repeatable Read ensures you always see the same snapshot.</p></div></div></section><section name="badc" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="e41e" id="e41e" class="graf graf--h3 graf--leading">Serializable: Strictest Isolation</h3><p name="b677" id="b677" class="graf graf--p graf-after--h3">With Serializable, PostgreSQL checks whether your transactions could produce different results than if they ran one after the other.</p><p name="ba34" id="ba34" class="graf graf--p graf-after--p">Session A:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="0967" id="0967" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">BEGIN</span>;<br /><span class="hljs-keyword">SET</span> TRANSACTION ISOLATION LEVEL SERIALIZABLE;<br /><br /><span class="hljs-keyword">SELECT</span> stock <span class="hljs-keyword">FROM</span> inventory <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br /><span class="hljs-comment">-- 100</span><br /><br /><span class="hljs-keyword">UPDATE</span> inventory <span class="hljs-keyword">SET</span> stock <span class="hljs-operator">=</span> stock <span class="hljs-operator">-</span> <span class="hljs-number">10</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;</span></pre><p name="c1c3" id="c1c3" class="graf graf--p graf-after--pre">Session B:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="1b6f" id="1b6f" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">BEGIN</span>;<br /><span class="hljs-keyword">SET</span> TRANSACTION ISOLATION LEVEL SERIALIZABLE;<br /><br /><span class="hljs-keyword">SELECT</span> stock <span class="hljs-keyword">FROM</span> inventory <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br /><span class="hljs-comment">-- 100</span><br /><br /><span class="hljs-keyword">UPDATE</span> inventory <span class="hljs-keyword">SET</span> stock <span class="hljs-operator">=</span> stock <span class="hljs-operator">-</span> <span class="hljs-number">20</span> <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br /><span class="hljs-keyword">COMMIT</span>;</span></pre><p name="577e" id="577e" class="graf graf--p graf-after--pre">Back in Session A:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="sql" name="62dc" id="62dc" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">COMMIT</span>;<br /><span class="hljs-comment">-- ERROR: could not serialize access due to concurrent update</span></span></pre><p name="c9f9" id="c9f9" class="graf graf--p graf-after--pre graf--trailing">PostgreSQL detects that running these transactions together could lead to inconsistencies, so it rolls one back. Better safe than sorry.</p></div></div></section><section name="9236" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="8b04" id="8b04" class="graf graf--h3 graf--leading">Choosing the Right Level</h3><ul class="postList"><li name="8f20" id="8f20" class="graf graf--li graf-after--h3"><strong class="markup--strong markup--li-strong">Read Committed</strong> works well for most use cases where short transactions don’t need repeatable reads.</li><li name="c2ba" id="c2ba" class="graf graf--li graf-after--li"><strong class="markup--strong markup--li-strong">Repeatable Read</strong> is useful for consistent reads in longer transactions or reports.</li><li name="f96a" id="f96a" class="graf graf--li graf-after--li graf--trailing"><strong class="markup--strong markup--li-strong">Serializable</strong> is the safest but can lead to transaction rollbacks, so you need to handle retries.</li></ul></div></div></section><section name="411c" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="681f" id="681f" class="graf graf--h3 graf--leading">Final Thoughts</h3><p name="6180" id="6180" class="graf graf--p graf-after--h3">Isolation is about making sure your transactions don’t see each other’s work half-finished. It’s not something you think about every day- until things go wrong because of subtle race conditions.</p><p name="72bb" id="72bb" class="graf graf--p graf-after--p graf--trailing">Getting Isolation right is key to safe and predictable data in multi-user systems. Now you know what each level does and how PostgreSQL keeps your data consistent even when things get busy.</p></div></div></section><section name="57a3" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="10ab" id="10ab" class="graf graf--h3 graf--leading">References</h3><ul class="postList"><li name="de70" id="de70" class="graf graf--li graf-after--h3"><a href="https://www.postgresql.org/docs/current/transaction-iso.html" data-href="https://www.postgresql.org/docs/current/transaction-iso.html" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">PostgreSQL: Isolation Levels</a></li><li name="de3d" id="de3d" class="graf graf--li graf-after--li graf--trailing"><a href="https://www.postgresql.org/docs/current/transaction-iso.html#XACT-SERIALIZABLE" data-href="https://www.postgresql.org/docs/current/transaction-iso.html#XACT-SERIALIZABLE" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">PostgreSQL: Serializable Isolation</a></li></ul></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@Kfir-G" class="p-author h-card">Kfir Gisman</a> on <a href="https://medium.com/p/c493d635a35b"><time class="dt-published" datetime="2025-07-07T18:28:31.736Z">July 7, 2025</time></a>.</p><p><a href="https://medium.com/@Kfir-G/understanding-isolation-in-postgresql-a-deep-dive-into-the-i-in-acid-c493d635a35b" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 20, 2025.</p></footer></article></body></html>