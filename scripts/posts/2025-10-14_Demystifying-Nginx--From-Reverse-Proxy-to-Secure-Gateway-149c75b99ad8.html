<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Demystifying Nginx: From Reverse Proxy to Secure Gateway</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Demystifying Nginx: From Reverse Proxy to Secure Gateway</h1>
</header>
<section data-field="subtitle" class="p-summary">
When I started building TinyURL, a simple FastAPI + PostgreSQL service for shortening URLs, I thought Nginx would just “serve traffic.”…
</section>
<section data-field="body" class="e-content">
<section name="4972" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="a9ec" id="a9ec" class="graf graf--h3 graf--leading graf--title">Demystifying Nginx: From Reverse Proxy to Secure Gateway</h3><figure name="55a7" id="55a7" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*5v3hP9YGA3i-1K5f9gVDFA.jpeg" data-width="1280" data-height="853" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*5v3hP9YGA3i-1K5f9gVDFA.jpeg"><figcaption class="imageCaption">Photo by RealToughCandy.com: <a href="https://www.pexels.com/photo/person-holding-a-sticker-with-green-letters-11035538/" data-href="https://www.pexels.com/photo/person-holding-a-sticker-with-green-letters-11035538/" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">https://www.pexels.com/photo/person-holding-a-sticker-with-green-letters-11035538/</a></figcaption></figure><p name="499b" id="499b" class="graf graf--p graf-after--figure">When I started building <strong class="markup--strong markup--p-strong">TinyURL</strong>, a simple FastAPI + PostgreSQL service for shortening URLs, I thought Nginx would just “serve traffic.” Turns out, it became the most critical piece of my deployment — the gatekeeper that made everything behind it work smoothly and securely.</p><p name="f067" id="f067" class="graf graf--p graf-after--p graf--trailing">In this post, I’ll share what I actually learned while wiring Nginx into my FastAPI backend and Streamlit frontend, both running in Docker.</p></div></div></section><section name="207c" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="2115" id="2115" class="graf graf--h3 graf--leading">1. Nginx is more than a web server</h3><p name="6bce" id="6bce" class="graf graf--p graf-after--h3">Before this project, I mostly thought of Nginx as something you use to “host static files.” In reality, it’s a powerful <strong class="markup--strong markup--p-strong">reverse proxy</strong> — it sits in front of your app, receives every incoming request, and decides where it should go.</p><p name="b445" id="b445" class="graf graf--p graf-after--p">In my stack:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="scss" name="3714" id="3714" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">Client → Nginx → FastAPI (backend) → Postgres<br />                     ↳ Streamlit (UI)</span></pre><p name="4532" id="4532" class="graf graf--p graf-after--pre">Nginx doesn’t just forward traffic- it also:</p><ul class="postList"><li name="3f73" id="3f73" class="graf graf--li graf-after--p">Handles HTTPS termination</li><li name="c891" id="c891" class="graf graf--li graf-after--li">Adds security headers</li><li name="2cde" id="2cde" class="graf graf--li graf-after--li">Manages WebSocket upgrades for Streamlit</li><li name="3114" id="3114" class="graf graf--li graf-after--li">Hides internal services (FastAPI and Postgres) from the public internet</li></ul><p name="fd50" id="fd50" class="graf graf--p graf-after--li graf--trailing">Once I saw that flow working inside Docker Compose, it finally clicked how production apps are structured.</p></div></div></section><section name="09ef" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="1ff2" id="1ff2" class="graf graf--h3 graf--leading">2. Reverse proxying is all about headers and trust</h3><p name="66db" id="66db" class="graf graf--p graf-after--h3">Here’s a simplified version of my production config:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="bash" name="b64a" id="b64a" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">location /api/ {<br />    proxy_pass http://fastapi:8000;<br />    proxy_set_header Host <span class="hljs-variable">$host</span>;<br />    proxy_set_header X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br />    proxy_set_header X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br />    proxy_set_header X-Forwarded-Proto <span class="hljs-variable">$scheme</span>;<br />}</span></pre><p name="eb70" id="eb70" class="graf graf--p graf-after--pre">These headers are crucial. Without them, FastAPI would have no idea what the original client’s IP or scheme was.<br> <code class="markup--code markup--p-code">X-Forwarded-Proto</code> in particular tells the backend if the original request came over HTTPS- that’s how FastAPI can generate correct redirect URLs or absolute links.</p><p name="dece" id="dece" class="graf graf--p graf-after--p graf--trailing">This part made me appreciate how Nginx “translates” external requests for internal services while preserving client context.</p></div></div></section><section name="a83e" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="c616" id="c616" class="graf graf--h3 graf--leading">3. HTTPS is not optional</h3><p name="9aab" id="9aab" class="graf graf--p graf-after--h3">The first time I tried running my app on an EC2 instance, Chrome immediately complained: <em class="markup--em markup--p-em">“Not secure.”</em></p><p name="0e01" id="0e01" class="graf graf--p graf-after--p">That’s when I integrated <strong class="markup--strong markup--p-strong">Let’s Encrypt</strong> with Nginx. The setup was surprisingly simple once I understood what was happening:</p><ul class="postList"><li name="4267" id="4267" class="graf graf--li graf-after--p">The <code class="markup--code markup--li-code">/.well-known/acme-challenge/</code> path lets Certbot verify domain ownership.</li><li name="bcd6" id="bcd6" class="graf graf--li graf-after--li">Once validated, Let’s Encrypt issues free SSL certificates.</li><li name="7094" id="7094" class="graf graf--li graf-after--li">Nginx then terminates HTTPS using those certs:</li></ul><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="bash" name="4ed1" id="4ed1" class="graf graf--pre graf-after--li graf--preV2"><span class="pre--content">ssl_certificate /etc/letsencrypt/live/kg-tiny-url.xyz/fullchain.pem;<br />ssl_certificate_key /etc/letsencrypt/live/kg-tiny-url.xyz/privkey.pem;<br />ssl_protocols TLSv1.2 TLSv1.3;</span></pre><p name="b2b9" id="b2b9" class="graf graf--p graf-after--pre graf--trailing">I also learned to add a separate HTTP server block just to redirect everything to HTTPS. Small detail, big difference.</p></div></div></section><section name="00ac" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="7e3c" id="7e3c" class="graf graf--h3 graf--leading">4. Security headers are free wins</h3><p name="81b4" id="81b4" class="graf graf--p graf-after--h3">I wanted to understand what real production configs look like, so I dug into HTTP security headers. Adding these took one line each in Nginx but instantly hardened the app:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="python" name="bc27" id="bc27" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">add_header Strict-Transport-Security <span class="hljs-string">&quot;max-age=31536000&quot;</span> always;<br />add_header X-Frame-Options <span class="hljs-string">&quot;DENY&quot;</span> always;<br />add_header X-Content-<span class="hljs-type">Type</span>-Options <span class="hljs-string">&quot;nosniff&quot;</span> always;<br />add_header Content-Security-Policy <span class="hljs-string">&quot;default-src &#x27;self&#x27;&quot;</span> always;</span></pre><p name="6a31" id="6a31" class="graf graf--p graf-after--pre graf--trailing">You don’t notice them in daily use, but tools like Mozilla Observatory or Lighthouse will thank you.</p></div></div></section><section name="2309" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="4a97" id="4a97" class="graf graf--h3 graf--leading">5. Docker networking just works- if you name things right</h3><p name="f0b7" id="f0b7" class="graf graf--p graf-after--h3">Inside Docker Compose, every container gets a DNS name. My <code class="markup--code markup--p-code">proxy_pass http://fastapi:8000</code> line works because the FastAPI container is literally named <strong class="markup--strong markup--p-strong">fastapi</strong> in the YAML file.</p><p name="6810" id="6810" class="graf graf--p graf-after--p graf--trailing">That’s how Nginx can find it without any IP addresses.<br> Once I realized that Docker’s internal DNS makes service discovery effortless, networking suddenly felt simple instead of scary.</p></div></div></section><section name="2311" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="4c14" id="4c14" class="graf graf--h3 graf--leading">6. The moment it all worked</h3><p name="95ba" id="95ba" class="graf graf--p graf-after--h3">After wiring it all up, I opened my browser to:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="bash" name="7f98" id="7f98" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">https://kg-tiny-url.xyz/ui/</span></pre><p name="be1c" id="be1c" class="graf graf--p graf-after--pre">The Streamlit UI loaded. When I shortened a link, it called the FastAPI backend through <code class="markup--code markup--p-code">/api/</code>.<br> Everything was encrypted, routed, and logged properly- all through Nginx.</p><p name="6603" id="6603" class="graf graf--p graf-after--p graf--trailing">That was the moment I understood why every real-world deployment uses a reverse proxy.</p></div></div></section><section name="6d4b" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="0bcd" id="0bcd" class="graf graf--h3 graf--leading">7. Final takeaway</h3><p name="4451" id="4451" class="graf graf--p graf-after--h3">Nginx isn’t just a traffic router- it’s the <strong class="markup--strong markup--p-strong">security layer, performance booster, and network translator</strong> that makes containerized apps production-ready.</p><p name="ed0c" id="ed0c" class="graf graf--p graf-after--p graf--trailing">By the end of this project, I didn’t just “set up Nginx.” I learned how the internet actually talks to my code.</p></div></div></section><section name="1d56" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="0893" id="0893" class="graf graf--p graf--leading graf--trailing">If you’re new to Nginx or just want to deepen your understanding, I highly recommend pairing this write-up with <strong class="markup--strong markup--p-strong">this free YouTube tutorial</strong> (<a href="https://www.youtube.com/watch?v=7VAI73roXaY" data-href="https://www.youtube.com/watch?v=7VAI73roXaY" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">https://www.youtube.com/watch?v=7VAI73roXaY</a>) for a hands-on introduction, and <strong class="markup--strong markup--p-strong">the Udemy “NGINX Crash Course”</strong> (<a href="https://www.udemy.com/course/nginx-crash-course/?kw=ngi&amp;src=sac" data-href="https://www.udemy.com/course/nginx-crash-course/?kw=ngi&amp;src=sac" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">https://www.udemy.com/course/nginx-crash-course/?kw=ngi&amp;src=sac</a>) for a more structured, in-depth path. These two resources helped me grasp concepts like reverse proxying, SSL termination, WebSocket upgrades, and scaling more confidently — and I think they’ll help you too.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@Kfir-G" class="p-author h-card">Kfir Gisman</a> on <a href="https://medium.com/p/149c75b99ad8"><time class="dt-published" datetime="2025-10-14T02:20:43.582Z">October 14, 2025</time></a>.</p><p><a href="https://medium.com/@Kfir-G/demystifying-nginx-from-reverse-proxy-to-secure-gateway-149c75b99ad8" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on December 20, 2025.</p></footer></article></body></html>